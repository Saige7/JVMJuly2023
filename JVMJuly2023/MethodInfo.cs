using JVMJuly2023.AttributeClasses;
using JVMJuly2023.CPInfoClasses;
using System;
using System.Collections.Generic;
using System.Text;

namespace JVMJuly2023
{
    public class MethodInfo
    {
        public enum Flags : ushort
        {
            AccPublic = 0x0001,         //Declared public; may be accessed from outside its package.
            AccPrivate = 0x0002,	    //Declared private; accessible only within the defining class.
            AccProtected = 0x0004,	    //Declared protected; may be accessed within subclasses.
            AccStatic = 0x0008,	        //Declared static.
            AccFinal = 0x0010,	        //Declared final; must not be overridden(§5.4.5).
            AccSynchronized = 0x0020,	//Declared synchronized; invocation is wrapped by a monitor use.
            AccBridge = 0x0040,	        //A bridge method, generated by the compiler.
            AccVarags = 0x0080,	        //Declared with variable number of arguments.
            AccNative = 0x0100,	        //Declared native; implemented in a language other than Java.
            AccAbstrat = 0x0400,	    //Declared abstract; no implementation is provided.
            AccStrict = 0x0800,	        //Declared strictfp; floating-point mode is FP-strict.
            AccSynthetic = 0x1000	    //Declared synthetic; not present in the source code.
        }

        public ushort Flag { get; }
        public ushort NameIndex;
        public ushort DescriptorIndex;
        public AttributeInfo[] Attributes;
        public ushort accessFlag;

        //public MethodInfo(ushort flag, ushort nameIndex, ushort descriptorIndex, AttributeInfo[] attributes)
        //{
        //    Flag = flag;
        //    NameIndex = nameIndex;
        //    DescriptorIndex = descriptorIndex;
        //    Attributes = attributes;
        //}

        public MethodInfo(ushort accessFlag, ushort nameIndex, ushort descriptorIndex, AttributeInfo[] methodAttributes)
        {
            this.accessFlag = accessFlag;
            NameIndex = nameIndex;
            DescriptorIndex = descriptorIndex;
            Attributes = methodAttributes;
        }

        public static AttributeInfo[] MethodAttributes(byte[] Bytes, ushort methodAttributeCount, ref int currentIndex, CPInfo[] cpInfos)
        {
            AttributeInfo[] attributes = new AttributeInfo[methodAttributeCount];
            for(int i = 0; i < methodAttributeCount; i++)
            {
                ushort attributeNameIndex = (ushort)(Bytes[currentIndex] << 8 | Bytes[currentIndex + 1]);
                currentIndex += 2;
                uint attributeLength = (uint)(Bytes[currentIndex] << 24 | Bytes[currentIndex + 1] << 16 | Bytes[currentIndex + 2] << 8 | Bytes[currentIndex + 3]);
                currentIndex += 4;

                var bytes = ((ConstantUtf8Info)cpInfos[attributeNameIndex - 1]).Bytes;
                string value = Encoding.UTF8.GetString(bytes);
                switch (value)
                {
                    default: throw new Exception(":(");

                    case "Code":
                        Code code = new Code(attributeNameIndex, attributeLength, Bytes, ref currentIndex, cpInfos);
                        attributes[i] = code;
                        break;
                    case "LineNumberTable":
                        LineNumberTable lineNumberTable = new LineNumberTable(attributeNameIndex, attributeLength, Bytes, ref currentIndex);
                        attributes[i] = lineNumberTable;
                        break;
                    case "SourceFile":
                        SourceFile sourceFile = new SourceFile(attributeNameIndex, attributeLength, Bytes, ref currentIndex);
                        attributes[i] = sourceFile;
                        break;
                }
            }
            return attributes;
        }
    }
}
